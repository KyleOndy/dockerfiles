#!/usr/bin/env python3

import argparse
import collections
import concurrent.futures
import logging
import os
import subprocess
import sys

BASE = os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir))
LOG = logging.getLogger(__name__)


def run(*args, **kwargs):
    LOG.info(' '.join(args))
    subprocess.check_call(args, **kwargs)


def check_output(*args, **kwargs):
    LOG.info(' '.join(args))
    try:
        return subprocess.check_output(args, **kwargs)
    except subprocess.CalledProcessError as exc:
        print('STDOUT: ',
              exc.stdout.decode('utf8') if exc.stdout is not None else '')
        print('STDERR: ',
              exc.stderr.decode('utf8') if exc.stderr is not None else '')
        raise


def runexec(*args):
    LOG.info(' '.join(args))
    os.execlp(args[0], *args)


class Image(collections.namedtuple('Image', 'name depends')):
    _all = None
    registry = None

    @classmethod
    def _collect(cls):
        images = {}
        for dirpath, dirnames, filenames in os.walk(BASE):
            if 'Dockerfile' in filenames:
                fpath = os.path.join(dirpath, 'Dockerfile')
                name = '{}/{}'.format(
                    cls.registry,
                    dirpath[len(BASE) + 1:].replace('/', ':'))
                with open(fpath) as f:
                    for line in f:
                        if line.startswith('FROM '):
                            from_name = line.split(' ', 1)[1].strip()
                            if from_name == 'scratch':
                                continue
                            images.setdefault(from_name, set())
                            images.setdefault(name, set()).add(from_name)
                            images.setdefault(name, set())
        for name, depends in images.items():
            for dname in set(depends):
                depends |= images[dname]
        return sorted([cls(name, depends) for name, depends in images.items()],
                      key=lambda x: (len(x.depends), x.name))

    @classmethod
    def getall(cls):
        if cls._all is None:
            cls._all = cls._collect()
        return cls._all

    @classmethod
    def filter(cls, *names):
        for img in cls.getall():
            if img.is_local and (not names or img.short_name in names):
                yield img

    @classmethod
    def get(cls, name):
        images = list(cls.filter(name))
        try:
            return images[0]
        except IndexError:
            raise ValueError('No image matching {}'.format(repr(name)))

    @property
    def is_local(self):
        return self.name.startswith(self.registry)

    @property
    def short_name(self):
        assert self.is_local
        return self.name[len(self.registry) + 1:]

    def run(self):
        runexec('docker', 'run', '--rm', '-it', self.name)

    def test(self):
        runexec('docker', 'run', '--rm', '-it', '--entrypoint', 'sh',
                self.name)

    def build(self, no_cache=False, suffix=None):
        if self.is_local:
            context = os.path.join(BASE, self.short_name.replace(':', '/'))
            if self.short_name == 'alpine:3.8':
                rootfs = os.path.join(context, 'rootfs.tar.xz')
                if not os.path.exists(rootfs):
                    builder = self.get('alpine:builder')
                    builder.build(no_cache=no_cache, suffix=suffix)
                    run('docker run --rm {} -r v3.8 '
                        '-m http://dl-cdn.alpinelinux.org/alpine '
                        '-b -t UTC '
                        '-p alpine-baselayout,busybox,'
                        'alpine-keys,apk-tools,libc-utils '
                        '-s > {}'.format(builder.name, rootfs), shell=True)
            if suffix is not None:
                if ':' in self.name:
                    tag = '{}-{}'.format(self.name, suffix)
                else:
                    tag = '{}:{}'.format(self.name, suffix)
            else:
                tag = self.name
            cmd = ['docker', 'build', '-t', tag, context]
            if no_cache:
                cmd += ['--no-cache']
            run(*cmd)
            if tag is not None:
                run('docker', 'tag', tag, self.name)
        else:
            self.pull()

    def pull(self):
        run('docker', 'pull', self.name)

    def push(self, **kwargs):
        assert self.is_local
        self.build(**kwargs)
        run('docker', 'push', self.name)

    def check(self):
        assert self.is_local
        if self.short_name == 'alpine:3.8' or any(
                'alpine' in d for d in self.depends):
            output = check_output(
                'docker', 'run', '--rm', '-it', '--entrypoint', 'sh',
                '-u', 'root', self.name, '-c',
                'apk --no-cache list -u')
        elif any('debian' in d for d in self.depends):
            output = check_output(
                'docker', 'run', '--rm', '-it', '--entrypoint', 'sh',
                '-u', 'root', self.name, '-c',
                'apt-get update > /dev/null && apt list --upgradable')
        else:
            output = b''
        print(output.decode())

    def async(func, *names):
        futures = []
        with concurrent.futures.ThreadPoolExecutor(max_workers=4) as e:
            for img in Image.filter(*names):
                f, args, kwargs = func(img)
                futures.append(e.submit(f, *args, **kwargs))
        return [f.result() for f in futures]


def cmd_build(image, **kwargs):
    Image.async(lambda i: (i.build, (), kwargs), *image)


def cmd_push(image, **kwargs):
    Image.async(lambda i: (i.push, (), kwargs), *image)


def cmd_pull(image):
    Image.async(lambda i: (i.pull, (), {}), *image)


def cmd_check(image):
    Image.async(lambda i: (i.check, (), {}), *image)


def cmd_run(image):
    img = Image.get(image)
    img.build()
    img.run()


def cmd_test(image):
    img = Image.get(image)
    img.build()
    img.test()


def cmd_list():
    for img in Image.getall():
        if img.is_local:
            print(img.short_name)


if __name__ == '__main__':
    logging.basicConfig(format='%(asctime)-15s %(message)s')
    LOG.setLevel(logging.INFO)
    parser = argparse.ArgumentParser(description=(
        'docker image lifecycle handling'))
    parser.add_argument('-r', '--registry', default='r.philpep.org')
    sub = parser.add_subparsers()
    cmds = {}
    for action, nargs, func in (
        ('build', '*', cmd_build),
        ('push', '*', cmd_push),
        ('pull', '*', cmd_pull),
        ('check', '*', cmd_check),
        ('run', None, cmd_run),
        ('test', None, cmd_test),
    ):
        cmds[action] = cmd = sub.add_parser(action)
        if nargs is not None:
            cmd.add_argument('image', nargs=nargs)
        else:
            cmd.add_argument('image')
        cmd.set_defaults(func=func)
    cmds['list'] = sub.add_parser('list', aliases=['ls'])
    cmds['list'].set_defaults(func=cmd_list)
    for action in ('build', 'push'):
        cmds[action].add_argument('--no-cache', action='store_true')
        cmds[action].add_argument('--suffix')
    args = vars(parser.parse_args())
    func = args.pop('func', None)
    Image.registry = args.pop('registry')
    if func is not None:
        sys.exit(func(**args) or 0)
    else:
        parser.parse_args(['--help'])
